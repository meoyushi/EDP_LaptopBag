{"ast":null,"code":"var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = exports.MapPolyline = void 0;\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));\nvar React = _interopRequireWildcard(require(\"react\"));\nvar _decorateMapComponent = _interopRequireWildcard(require(\"./decorateMapComponent\"));\nvar _jsxRuntime = require(\"react/jsx-runtime\");\nvar _jsxFileName = \"/workspaces/EDP_LaptopBag/frontend/node_modules/react-native-maps/src/MapPolyline.tsx\";\nfunction _interopRequireWildcard(e, t) { if (\"function\" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function _interopRequireWildcard(e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || \"object\" != typeof e && \"function\" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (var _t in e) \"default\" !== _t && {}.hasOwnProperty.call(e, _t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, _t)) && (i.get || i.set) ? o(f, _t, i) : f[_t] = e[_t]); return f; })(e, t); }\nfunction _callSuper(t, o, e) { return o = (0, _getPrototypeOf2.default)(o), (0, _possibleConstructorReturn2.default)(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], (0, _getPrototypeOf2.default)(t).constructor) : o.apply(t, e)); }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nvar MapPolyline = exports.MapPolyline = function (_React$Component) {\n  function MapPolyline(props) {\n    var _this;\n    (0, _classCallCheck2.default)(this, MapPolyline);\n    _this = _callSuper(this, MapPolyline, [props]);\n    _this.polyline = React.createRef();\n    return _this;\n  }\n  (0, _inherits2.default)(MapPolyline, _React$Component);\n  return (0, _createClass2.default)(MapPolyline, [{\n    key: \"setNativeProps\",\n    value: function setNativeProps(props) {\n      var _this$polyline$curren;\n      (_this$polyline$curren = this.polyline.current) == null ? void 0 : _this$polyline$curren.setNativeProps(props);\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this$props = this.props,\n        _this$props$strokeCol = _this$props.strokeColor,\n        strokeColor = _this$props$strokeCol === void 0 ? '#000' : _this$props$strokeCol,\n        _this$props$strokeWid = _this$props.strokeWidth,\n        strokeWidth = _this$props$strokeWid === void 0 ? 1 : _this$props$strokeWid,\n        _this$props$lineJoin = _this$props.lineJoin,\n        lineJoin = _this$props$lineJoin === void 0 ? 'round' : _this$props$lineJoin,\n        _this$props$lineCap = _this$props.lineCap,\n        lineCap = _this$props$lineCap === void 0 ? 'round' : _this$props$lineCap;\n      var AIRMapPolyline = this.getNativeComponent();\n      return (0, _jsxRuntime.jsx)(AIRMapPolyline, Object.assign({}, this.props, {\n        strokeColor: strokeColor,\n        strokeWidth: strokeWidth,\n        lineJoin: lineJoin,\n        lineCap: lineCap,\n        ref: this.polyline\n      }));\n    }\n  }]);\n}(React.Component);\nvar _default = exports.default = (0, _decorateMapComponent.default)(MapPolyline, 'Polyline', {\n  google: {\n    ios: _decorateMapComponent.SUPPORTED,\n    android: _decorateMapComponent.USES_DEFAULT_IMPLEMENTATION\n  }\n});","map":{"version":3,"names":["React","_interopRequireWildcard","require","_decorateMapComponent","_jsxRuntime","_jsxFileName","e","t","WeakMap","r","n","__esModule","o","i","f","__proto__","default","has","get","set","_t","hasOwnProperty","call","Object","defineProperty","getOwnPropertyDescriptor","_callSuper","_getPrototypeOf2","_possibleConstructorReturn2","_isNativeReflectConstruct","Reflect","construct","constructor","apply","Boolean","prototype","valueOf","MapPolyline","exports","_React$Component","props","_this","_classCallCheck2","polyline","createRef","_inherits2","_createClass2","key","value","setNativeProps","_this$polyline$curren","current","render","_this$props","_this$props$strokeCol","strokeColor","_this$props$strokeWid","strokeWidth","_this$props$lineJoin","lineJoin","_this$props$lineCap","lineCap","AIRMapPolyline","getNativeComponent","jsx","assign","ref","Component","_default","decorateMapComponent","google","ios","SUPPORTED","android","USES_DEFAULT_IMPLEMENTATION"],"sources":["/workspaces/EDP_LaptopBag/frontend/node_modules/react-native-maps/src/MapPolyline.tsx"],"sourcesContent":["import * as React from 'react';\nimport {View, type NativeSyntheticEvent, type ViewProps} from 'react-native';\nimport decorateMapComponent, {\n  USES_DEFAULT_IMPLEMENTATION,\n  SUPPORTED,\n  ProviderContext,\n  type NativeComponent,\n  type MapManagerCommand,\n  type UIManagerCommand,\n} from './decorateMapComponent';\nimport type {LatLng, LineCapType, LineJoinType, Point} from './sharedTypes';\n\nexport type MapPolylineProps = ViewProps & {\n  /**\n   * An array of coordinates to describe the polyline\n   *\n   * @platform iOS: Supported\n   * @platform Android: Supported\n   */\n  coordinates: LatLng[];\n\n  /**\n   * The fill color to use for the path.\n   *\n   * @default `#000`, `rgba(r,g,b,0.5)`\n   * @platform iOS: Apple Maps only\n   * @platform Android: Not supported\n   */\n  fillColor?: string;\n\n  /**\n   * Boolean to indicate whether to draw each segment of the line as a geodesic as opposed to straight lines on the Mercator projection.\n   * A geodesic is the shortest path between two points on the Earth's surface.\n   * The geodesic curve is constructed assuming the Earth is a sphere.\n   *\n   * @platform iOS: Google Maps only\n   * @platform Android: Supported\n   */\n  geodesic?: boolean;\n\n  /**\n   * The line cap style to apply to the open ends of the path\n   *\n   * @default `round`\n   * @platform iOS: Apple Maps only\n   * @platform Android: supported\n   * */\n  lineCap?: LineCapType;\n\n  /**\n   * An array of numbers specifying the dash pattern to use for the path.\n   * The array contains one or more numbers that indicate the lengths (measured in points)\n   * of the line segments and gaps in the pattern.\n   * The values in the array alternate, starting with the first line segment length,\n   * followed by the first gap length, followed by the second line segment length, and so on.\n   *\n   * @platform iOS: Apple Maps only\n   * @platform Android: supported\n   */\n  lineDashPattern?: number[];\n\n  /**\n   * The offset (in points) at which to start drawing the dash pattern.\n   * Use this property to start drawing a dashed line partway through a segment or gap.\n   * For example, a phase value of 6 for the patter 5-2-3-2 would cause drawing to begin in the middle of the first gap.\n   *\n   * @default 0\n   * @platform iOS: Apple Maps only\n   * @platform Android: Not supported\n   */\n  lineDashPhase?: number;\n\n  /**\n   * The line join style to apply to corners of the path.\n   *\n   * @platform iOS: Apple Maps only\n   * @platform Android: supported\n   */\n  lineJoin?: LineJoinType;\n\n  /**\n   * The limiting value that helps avoid spikes at junctions between connected line segments.\n   * The miter limit helps you avoid spikes in paths that use the `miter` `lineJoin` style.\n   * If the ratio of the miter length—that is, the diagonal length of the miter join—to the line thickness exceeds the miter limit,\n   * the joint is converted to a bevel join.\n   * The default miter limit is 10, which results in the conversion of miters whose angle at the joint is less than 11 degrees.\n   *\n   * @default 10\n   * @platform iOS: Apple Maps only\n   * @platform Android: Not supported\n   */\n  miterLimit?: number;\n\n  /**\n   * Callback that is called when the user presses on the polyline\n   *\n   * @platform iOS: Supported\n   * @platform Android: Supported\n   */\n  onPress?: (event: PolylinePressEvent) => void;\n\n  /**\n   * The stroke color to use for the path.\n   *\n   * @default `#000`, `rgba(r,g,b,0.5)`\n   * @platform iOS: Supported\n   * @platform Android: Supported\n   */\n  strokeColor?: string;\n\n  /**\n   * The stroke colors to use for the path.\n   *\n   * Must be the same length as `coordinates`\n   *\n   * @platform iOS: Supported\n   * @platform Android: Supported\n   */\n  strokeColors?: string[];\n\n  /**\n   * The stroke width to use for the path.\n   *\n   * @default 1\n   * @platform iOS: Supported\n   * @platform Android: Supported\n   */\n  strokeWidth?: number;\n\n  /**\n   * Boolean to allow the polyline to be tappable and use the onPress function.\n   *\n   * @platform iOS: Google Maps only\n   * @platform Android: Supported\n   */\n  tappable?: boolean;\n\n  /**\n   * The order in which this tile overlay is drawn with respect to other overlays.\n   * An overlay with a larger z-index is drawn over overlays with smaller z-indices.\n   * The order of overlays with the same z-index is arbitrary.\n   *\n   * @platform iOS: Google Maps only\n   * @platform Android: Supported\n   */\n  zIndex?: number;\n};\n\ntype NativeProps = MapPolylineProps & {ref: React.RefObject<View | null>};\n\nexport class MapPolyline extends React.Component<MapPolylineProps> {\n  // declaration only, as they are set through decorateMap\n  /// @ts-ignore\n  context!: React.ContextType<typeof ProviderContext>;\n  getNativeComponent!: () => NativeComponent<NativeProps>;\n  getMapManagerCommand!: (name: string) => MapManagerCommand;\n  getUIManagerCommand!: (name: string) => UIManagerCommand;\n\n  private polyline: NativeProps['ref'];\n\n  constructor(props: MapPolylineProps) {\n    super(props);\n    this.polyline = React.createRef<View>();\n  }\n\n  setNativeProps(props: Partial<NativeProps>) {\n    this.polyline.current?.setNativeProps(props);\n  }\n\n  render() {\n    const {\n      strokeColor = '#000',\n      strokeWidth = 1,\n      lineJoin = 'round',\n      lineCap = 'round',\n    } = this.props;\n    const AIRMapPolyline = this.getNativeComponent();\n    return (\n      <AIRMapPolyline\n        {...this.props}\n        strokeColor={strokeColor}\n        strokeWidth={strokeWidth}\n        lineJoin={lineJoin}\n        lineCap={lineCap}\n        ref={this.polyline}\n      />\n    );\n  }\n}\n\nexport default decorateMapComponent(MapPolyline, 'Polyline', {\n  google: {\n    ios: SUPPORTED,\n    android: USES_DEFAULT_IMPLEMENTATION,\n  },\n});\n\nexport type PolylinePressEvent = NativeSyntheticEvent<{\n  action: 'polyline-press';\n\n  /**\n   * @platform iOS: Google Maps\n   */\n  id?: string;\n\n  /**\n   * @platform Android\n   */\n  coordinate?: LatLng;\n\n  /**\n   * @platform Android\n   */\n  position?: Point;\n}>;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}