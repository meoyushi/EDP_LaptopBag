{"ast":null,"code":"var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\nvar React = _interopRequireWildcard(require(\"react\"));\nvar _MapMarker = _interopRequireDefault(require(\"./MapMarker\"));\nvar _MapPolyline = _interopRequireDefault(require(\"./MapPolyline\"));\nvar _MapPolygon = _interopRequireDefault(require(\"./MapPolygon\"));\nvar _jsxRuntime = require(\"react/jsx-runtime\");\nvar _this = this,\n  _jsxFileName = \"/workspaces/EDP_LaptopBag/frontend/node_modules/react-native-maps/src/Geojson.tsx\";\nfunction _interopRequireWildcard(e, t) { if (\"function\" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function _interopRequireWildcard(e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || \"object\" != typeof e && \"function\" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (var _t in e) \"default\" !== _t && {}.hasOwnProperty.call(e, _t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, _t)) && (i.get || i.set) ? o(f, _t, i) : f[_t] = e[_t]); return f; })(e, t); }\nvar Geojson = function Geojson(props) {\n  var anchor = props.anchor,\n    centerOffset = props.centerOffset,\n    geojson = props.geojson,\n    strokeColor = props.strokeColor,\n    fillColor = props.fillColor,\n    strokeWidth = props.strokeWidth,\n    color = props.color,\n    title = props.title,\n    image = props.image,\n    zIndex = props.zIndex,\n    _onPress = props.onPress,\n    lineCap = props.lineCap,\n    lineJoin = props.lineJoin,\n    tappable = props.tappable,\n    tracksViewChanges = props.tracksViewChanges,\n    miterLimit = props.miterLimit,\n    lineDashPhase = props.lineDashPhase,\n    lineDashPattern = props.lineDashPattern,\n    markerComponent = props.markerComponent;\n  var pointOverlays = makePointOverlays(geojson.features);\n  var lineOverlays = makeLineOverlays(geojson.features);\n  var polygonOverlays = makePolygonOverlays(geojson.features);\n  return (0, _jsxRuntime.jsxs)(React.Fragment, {\n    children: [pointOverlays.map(function (overlay, index) {\n      var _overlay$feature$prop;\n      var markerColor = getColor(color, overlay, 'marker-color');\n      var pointOverlayTracksViewChanges = ((_overlay$feature$prop = overlay.feature.properties) == null ? void 0 : _overlay$feature$prop.tracksViewChanges) || tracksViewChanges;\n      return (0, _jsxRuntime.jsx)(_MapMarker.default, {\n        coordinate: overlay.coordinates,\n        tracksViewChanges: pointOverlayTracksViewChanges,\n        image: image,\n        title: title,\n        pinColor: markerColor,\n        zIndex: zIndex,\n        anchor: anchor,\n        centerOffset: centerOffset,\n        onPress: function onPress() {\n          return _onPress && _onPress(overlay);\n        },\n        children: markerComponent\n      }, index);\n    }), lineOverlays.map(function (overlay, index) {\n      var lineStrokeColor = getColor(strokeColor, overlay, 'stroke');\n      var lineStrokeWidth = getStrokeWidth(strokeWidth, overlay);\n      return (0, _jsxRuntime.jsx)(_MapPolyline.default, {\n        coordinates: overlay.coordinates,\n        strokeColor: lineStrokeColor,\n        strokeWidth: lineStrokeWidth,\n        lineDashPhase: lineDashPhase,\n        lineDashPattern: lineDashPattern,\n        lineCap: lineCap,\n        lineJoin: lineJoin,\n        miterLimit: miterLimit,\n        zIndex: zIndex,\n        tappable: tappable,\n        onPress: function onPress() {\n          return _onPress && _onPress(overlay);\n        }\n      }, index);\n    }), polygonOverlays.map(function (overlay, index) {\n      var polygonFillColor = getColor(fillColor, overlay, 'fill');\n      var lineStrokeColor = getColor(strokeColor, overlay, 'stroke');\n      var lineStrokeWidth = getStrokeWidth(strokeWidth, overlay);\n      return (0, _jsxRuntime.jsx)(_MapPolygon.default, {\n        coordinates: overlay.coordinates,\n        holes: overlay.holes,\n        strokeColor: lineStrokeColor,\n        fillColor: polygonFillColor,\n        strokeWidth: lineStrokeWidth,\n        lineDashPhase: lineDashPhase,\n        lineDashPattern: lineDashPattern,\n        lineCap: lineCap,\n        lineJoin: lineJoin,\n        miterLimit: miterLimit,\n        tappable: tappable,\n        onPress: function onPress() {\n          return _onPress && _onPress(overlay);\n        },\n        zIndex: zIndex\n      }, index);\n    })]\n  });\n};\nvar _default = exports.default = Geojson;\nvar makePointOverlays = function makePointOverlays(features) {\n  return features.filter(isAnyPointFeature).map(function (feature) {\n    return makeCoordinatesForAnyPoint(feature.geometry).map(function (coordinates) {\n      return makeOverlayForAnyPoint(coordinates, feature);\n    });\n  }).reduce(function (prev, curr) {\n    return prev.concat(curr);\n  }, []).map(function (overlay) {\n    return Object.assign({}, overlay, {\n      type: 'point'\n    });\n  });\n};\nvar makeLineOverlays = function makeLineOverlays(features) {\n  return features.filter(isAnyLineStringFeature).map(function (feature) {\n    return makeCoordinatesForAnyLine(feature.geometry).map(function (coordinates) {\n      return makeOverlayForAnyLine(coordinates, feature);\n    });\n  }).reduce(function (prev, curr) {\n    return prev.concat(curr);\n  }, []).map(function (overlay) {\n    return Object.assign({}, overlay, {\n      type: 'polyline'\n    });\n  });\n};\nvar makePolygonOverlays = function makePolygonOverlays(features) {\n  var multipolygons = features.filter(isMultiPolygonFeature).map(function (feature) {\n    return makeCoordinatesForMultiPolygon(feature.geometry).map(function (coordinates) {\n      return makeOverlayForAnyPolygon(coordinates, feature);\n    });\n  }).reduce(function (prev, curr) {\n    return prev.concat(curr);\n  }, []).map(function (overlay) {\n    return Object.assign({}, overlay, {\n      type: 'polygon'\n    });\n  });\n  var polygons = features.filter(isPolygonFeature).map(function (feature) {\n    return makeOverlayForAnyPolygon(makeCoordinatesForPolygon(feature.geometry), feature);\n  }).reduce(function (prev, curr) {\n    return prev.concat(curr);\n  }, []).map(function (overlay) {\n    return Object.assign({}, overlay, {\n      type: 'polygon'\n    });\n  });\n  return polygons.concat(multipolygons);\n};\nvar makeOverlayForAnyPoint = function makeOverlayForAnyPoint(coordinates, feature) {\n  return {\n    feature: feature,\n    coordinates: coordinates\n  };\n};\nvar makeOverlayForAnyLine = function makeOverlayForAnyLine(coordinates, feature) {\n  return {\n    feature: feature,\n    coordinates: coordinates\n  };\n};\nvar makeOverlayForAnyPolygon = function makeOverlayForAnyPolygon(coordinates, feature) {\n  return {\n    feature: feature,\n    coordinates: coordinates[0],\n    holes: coordinates.length > 1 ? coordinates.slice(1) : undefined\n  };\n};\nvar makePoint = function makePoint(c) {\n  return {\n    latitude: c[1],\n    longitude: c[0]\n  };\n};\nvar makeLine = function makeLine(l) {\n  return l.map(makePoint);\n};\nvar makeCoordinatesForAnyPoint = function makeCoordinatesForAnyPoint(geometry) {\n  if (geometry.type === 'Point') {\n    return [makePoint(geometry.coordinates)];\n  }\n  return geometry.coordinates.map(makePoint);\n};\nvar makeCoordinatesForAnyLine = function makeCoordinatesForAnyLine(geometry) {\n  if (geometry.type === 'LineString') {\n    return [makeLine(geometry.coordinates)];\n  }\n  return geometry.coordinates.map(makeLine);\n};\nvar makeCoordinatesForPolygon = function makeCoordinatesForPolygon(geometry) {\n  return geometry.coordinates.map(makeLine);\n};\nvar makeCoordinatesForMultiPolygon = function makeCoordinatesForMultiPolygon(geometry) {\n  return geometry.coordinates.map(function (p) {\n    return p.map(makeLine);\n  });\n};\nvar getRgbaFromHex = function getRgbaFromHex(hex) {\n  var alpha = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  var matchArray = hex.match(/\\w\\w/g);\n  if (!matchArray || matchArray.length < 3) {\n    throw new Error('Invalid hex string');\n  }\n  var _matchArray$map = matchArray.map(function (x) {\n      var subColor = parseInt(x, 16);\n      if (Number.isNaN(subColor)) {\n        throw new Error('Invalid hex string');\n      }\n      return subColor;\n    }),\n    _matchArray$map2 = (0, _slicedToArray2.default)(_matchArray$map, 3),\n    r = _matchArray$map2[0],\n    g = _matchArray$map2[1],\n    b = _matchArray$map2[2];\n  return `rgba(${r},${g},${b},${alpha})`;\n};\nvar getColor = function getColor(prop, overlay, colorType) {\n  var _overlay$feature$prop2;\n  var color = (_overlay$feature$prop2 = overlay.feature.properties) == null ? void 0 : _overlay$feature$prop2[colorType];\n  if (color) {\n    var _overlay$feature$prop3;\n    var opacityProperty = colorType + '-opacity';\n    var alpha = (_overlay$feature$prop3 = overlay.feature.properties) == null ? void 0 : _overlay$feature$prop3[opacityProperty];\n    if (alpha && alpha !== '0' && color[0] === '#') {\n      color = getRgbaFromHex(color, alpha);\n    }\n    return color;\n  } else if (prop) {\n    return prop;\n  }\n  return undefined;\n};\nvar getStrokeWidth = function getStrokeWidth(prop, overlay) {\n  var _overlay$feature$prop4, _overlay$feature$prop5;\n  return (_overlay$feature$prop4 = (_overlay$feature$prop5 = overlay.feature.properties) == null ? void 0 : _overlay$feature$prop5['stroke-width']) != null ? _overlay$feature$prop4 : prop;\n};\nvar isPointFeature = function isPointFeature(feature) {\n  return feature.geometry.type === 'Point';\n};\nvar isMultiPointFeature = function isMultiPointFeature(feature) {\n  return feature.geometry.type === 'MultiPoint';\n};\nvar isAnyPointFeature = function isAnyPointFeature(feature) {\n  return isPointFeature(feature) || isMultiPointFeature(feature);\n};\nvar isLineStringFeature = function isLineStringFeature(feature) {\n  return feature.geometry.type === 'LineString';\n};\nvar isMultiLineStringFeature = function isMultiLineStringFeature(feature) {\n  return feature.geometry.type === 'MultiLineString';\n};\nvar isAnyLineStringFeature = function isAnyLineStringFeature(feature) {\n  return isLineStringFeature(feature) || isMultiLineStringFeature(feature);\n};\nvar isPolygonFeature = function isPolygonFeature(feature) {\n  return feature.geometry.type === 'Polygon';\n};\nvar isMultiPolygonFeature = function isMultiPolygonFeature(feature) {\n  return feature.geometry.type === 'MultiPolygon';\n};","map":{"version":3,"names":["React","_interopRequireWildcard","require","_MapMarker","_interopRequireDefault","_MapPolyline","_MapPolygon","_jsxRuntime","_this","_jsxFileName","e","t","WeakMap","r","n","__esModule","o","i","f","__proto__","default","has","get","set","_t","hasOwnProperty","call","Object","defineProperty","getOwnPropertyDescriptor","Geojson","props","anchor","centerOffset","geojson","strokeColor","fillColor","strokeWidth","color","title","image","zIndex","onPress","lineCap","lineJoin","tappable","tracksViewChanges","miterLimit","lineDashPhase","lineDashPattern","markerComponent","pointOverlays","makePointOverlays","features","lineOverlays","makeLineOverlays","polygonOverlays","makePolygonOverlays","jsxs","Fragment","children","map","overlay","index","_overlay$feature$prop","markerColor","getColor","pointOverlayTracksViewChanges","feature","properties","jsx","coordinate","coordinates","pinColor","lineStrokeColor","lineStrokeWidth","getStrokeWidth","polygonFillColor","holes","_default","exports","filter","isAnyPointFeature","makeCoordinatesForAnyPoint","geometry","makeOverlayForAnyPoint","reduce","prev","curr","concat","assign","type","isAnyLineStringFeature","makeCoordinatesForAnyLine","makeOverlayForAnyLine","multipolygons","isMultiPolygonFeature","makeCoordinatesForMultiPolygon","makeOverlayForAnyPolygon","polygons","isPolygonFeature","makeCoordinatesForPolygon","length","slice","undefined","makePoint","c","latitude","longitude","makeLine","l","p","getRgbaFromHex","hex","alpha","arguments","matchArray","match","Error","_matchArray$map","x","subColor","parseInt","Number","isNaN","_matchArray$map2","_slicedToArray2","g","b","prop","colorType","_overlay$feature$prop2","_overlay$feature$prop3","opacityProperty","_overlay$feature$prop4","_overlay$feature$prop5","isPointFeature","isMultiPointFeature","isLineStringFeature","isMultiLineStringFeature"],"sources":["/workspaces/EDP_LaptopBag/frontend/node_modules/react-native-maps/src/Geojson.tsx"],"sourcesContent":["import * as React from 'react';\nimport type {\n  Feature,\n  FeatureCollection,\n  Point,\n  Position,\n  MultiPoint,\n  LineString,\n  MultiLineString,\n  Polygon,\n  MultiPolygon,\n} from 'geojson';\nimport Marker, {type MapMarkerProps as MarkerProps} from './MapMarker';\nimport type {MapPolygonProps as PolygonProps} from './MapPolygon';\nimport type {MapPolylineProps as PolylineProps} from './MapPolyline';\nimport Polyline from './MapPolyline';\nimport MapPolygon from './MapPolygon';\nimport type {LatLng} from './sharedTypes';\n\nexport type GeojsonProps = {\n  /**\n   * Sets the anchor point for the marker.\n   * The anchor specifies the point in the icon image that is anchored to the marker's position on the Earth's surface.\n   *\n   * The anchor point is specified in the continuous space [0.0, 1.0] x [0.0, 1.0],\n   * where (0, 0) is the top-left corner of the image, and (1, 1) is the bottom-right corner.\n   *\n   * The anchoring point in a W x H image is the nearest discrete grid point in a (W + 1) x (H + 1) grid, obtained by scaling the then rounding.\n   * For example, in a 4 x 2 image, the anchor point (0.7, 0.6) resolves to the grid point at (3, 1).\n   *\n   * @default {x: 0.5, y: 1.0}\n   * @platform iOS: Google Maps only. For Apple Maps, see the `centerOffset` prop\n   * @platform Android: Supported\n   */\n  anchor?: MarkerProps['anchor'];\n\n  /**\n   * The offset (in points) at which to display the annotation view.\n   *\n   * By default, the center point of an annotation view is placed at the coordinate point of the associated annotation.\n   *\n   * Positive offset values move the annotation view down and to the right, while negative values move it up and to the left.\n   *\n   * @default {x: 0.0, y: 0.0}\n   * @platform iOS: Apple Maps only. For Google Maps, see the `anchor` prop\n   * @platform Android: Not supported. See see the `anchor` prop\n   */\n  centerOffset?: MarkerProps['centerOffset'];\n\n  /**\n   * The pincolor used on markers\n   *\n   * @platform iOS: Supported\n   * @platform Android: Supported\n   */\n  color?: MarkerProps['pinColor'];\n\n  /**\n   * The fill color to use for the path.\n   *\n   * @platform iOS: Supported\n   * @platform Android: Supported\n   */\n  fillColor?: PolygonProps['fillColor'];\n\n  /**\n   * [Geojson](https://geojson.org/) description of object.\n   *\n   * @platform iOS: Supported\n   * @platform Android: Supported\n   */\n  geojson: FeatureCollection;\n\n  /**\n   * A custom image to be used as the marker's icon. Only local image resources are allowed to be\n   * used.\n   *\n   * @platform iOS: Supported\n   * @platform Android: Supported\n   */\n  image?: MarkerProps['image'];\n\n  /**\n   * The line cap style to apply to the open ends of the path.\n   * The default style is `round`.\n   *\n   * @platform iOS: Apple Maps only\n   * @platform Android: Supported\n   */\n  lineCap?: PolylineProps['lineCap'];\n\n  /**\n   * An array of numbers specifying the dash pattern to use for the path.\n   *\n   * The array contains one or more numbers that indicate the lengths (measured in points) of the\n   * line segments and gaps in the pattern. The values in the array alternate, starting with the\n   * first line segment length, followed by the first gap length, followed by the second line\n   * segment length, and so on.\n   *\n   * This property is set to `null` by default, which indicates no line dash pattern.\n   *\n   * @platform iOS: Supported\n   * @platform Android: Supported\n   */\n  lineDashPattern?:\n    | PolygonProps['lineDashPattern']\n    | PolylineProps['lineDashPattern'];\n\n  /**\n   * The offset (in points) at which to start drawing the dash pattern.\n   *\n   * Use this property to start drawing a dashed line partway through a segment or gap. For\n   * example, a phase value of 6 for the patter 5-2-3-2 would cause drawing to begin in the\n   * middle of the first gap.\n   *\n   * The default value of this property is 0.\n   *\n   * @platform iOS: Apple Maps only\n   * @platform Android: Not supported\n   */\n  lineDashPhase?: PolylineProps['lineDashPhase'];\n\n  /**\n   * The line join style to apply to corners of the path.\n   * The default style is `round`.\n   *\n   * @platform iOS: Apple Maps only\n   * @platform Android: Not supported\n   */\n  lineJoin?: PolylineProps['lineJoin'];\n\n  /**\n   * Component to render in place of the default marker when the overlay type is a `point`\n   *\n   * @platform iOS: Supported\n   * @platform Android: Supported\n   */\n  markerComponent?: MarkerProps['children'];\n\n  /**\n   * The limiting value that helps avoid spikes at junctions between connected line segments.\n   * The miter limit helps you avoid spikes in paths that use the `miter` `lineJoin` style. If\n   * the ratio of the miter length—that is, the diagonal length of the miter join—to the line\n   * thickness exceeds the miter limit, the joint is converted to a bevel join. The default\n   * miter limit is 10, which results in the conversion of miters whose angle at the joint\n   * is less than 11 degrees.\n   *\n   * @platform iOS: Apple Maps only\n   * @platform Android: Not supported\n   */\n  miterLimit?: PolylineProps['miterLimit'];\n\n  /**\n   * Callback that is called when the user presses any of the overlays\n   */\n  onPress?: (event: OverlayPressEvent) => void;\n\n  /**\n   * The stroke color to use for the path.\n   *\n   * @platform — iOS: Supported\n   * @platform — Android: Supported\n   */\n  strokeColor?: PolygonProps['strokeColor'] | PolylineProps['strokeColor'];\n\n  /**\n   * The stroke width to use for the path.\n   *\n   * @platform — iOS: Supported\n   * @platform — Android: Supported\n   */\n  strokeWidth?: PolygonProps['strokeWidth'] | PolylineProps['strokeWidth'];\n\n  /**\n   * Make the `Polygon` or `Polyline` tappable\n   *\n   * @platform — iOS: Google Maps only\n   * @platform — Android: Supported\n   */\n  tappable?: PolygonProps['tappable'] | PolylineProps['tappable'];\n\n  /**\n   * The title of the marker. This is only used if the <Marker /> component has no children that\n   * are a `<Callout />`, in which case the default callout behavior will be used, which\n   * will show both the `title` and the `description`, if provided.\n   *\n   * @platform — iOS: Supported\n   * @platform — Android: Supported\n   */\n  title?: MarkerProps['title'];\n\n  /**\n   * Sets whether this marker should track view changes.\n   * It's recommended to turn it off whenever it's possible to improve custom marker performance.\n   * This is the default value for all point markers in your geojson data. It can be overriden\n   * on a per point basis by adding a `trackViewChanges` property to the `properties` object on the point.\n   *\n   * @default true\n   * @platform iOS: Google Maps only\n   * @platform Android: Supported\n   */\n  tracksViewChanges?: boolean;\n\n  /**\n   * The order in which this tile overlay is drawn with respect to other overlays. An overlay\n   * with a larger z-index is drawn over overlays with smaller z-indices. The order of overlays\n   * with the same z-index is arbitrary. The default zIndex is 0.\n   *\n   * @platform iOS: Apple Maps: [Marker], Google Maps: [Marker, Polygon, Polyline]\n   * @platform Android: Supported\n   */\n  zIndex?:\n    | MarkerProps['zIndex']\n    | PolygonProps['zIndex']\n    | PolylineProps['zIndex'];\n};\n\nconst Geojson = (props: GeojsonProps) => {\n  const {\n    anchor,\n    centerOffset,\n    geojson,\n    strokeColor,\n    fillColor,\n    strokeWidth,\n    color,\n    title,\n    image,\n    zIndex,\n    onPress,\n    lineCap,\n    lineJoin,\n    tappable,\n    tracksViewChanges,\n    miterLimit,\n    lineDashPhase,\n    lineDashPattern,\n    markerComponent,\n  } = props;\n  const pointOverlays = makePointOverlays(geojson.features);\n  const lineOverlays = makeLineOverlays(geojson.features);\n  const polygonOverlays = makePolygonOverlays(geojson.features);\n  return (\n    <React.Fragment>\n      {pointOverlays.map((overlay, index) => {\n        const markerColor = getColor(color, overlay, 'marker-color');\n        const pointOverlayTracksViewChanges =\n          overlay.feature.properties?.tracksViewChanges || tracksViewChanges;\n        return (\n          <Marker\n            key={index}\n            coordinate={overlay.coordinates}\n            tracksViewChanges={pointOverlayTracksViewChanges}\n            image={image}\n            title={title}\n            pinColor={markerColor}\n            zIndex={zIndex}\n            anchor={anchor}\n            centerOffset={centerOffset}\n            onPress={() => onPress && onPress(overlay)}>\n            {markerComponent}\n          </Marker>\n        );\n      })}\n      {lineOverlays.map((overlay, index) => {\n        const lineStrokeColor = getColor(strokeColor, overlay, 'stroke');\n        const lineStrokeWidth = getStrokeWidth(strokeWidth, overlay);\n\n        return (\n          <Polyline\n            key={index}\n            coordinates={overlay.coordinates}\n            strokeColor={lineStrokeColor}\n            strokeWidth={lineStrokeWidth}\n            lineDashPhase={lineDashPhase}\n            lineDashPattern={lineDashPattern}\n            lineCap={lineCap}\n            lineJoin={lineJoin}\n            miterLimit={miterLimit}\n            zIndex={zIndex}\n            tappable={tappable}\n            onPress={() => onPress && onPress(overlay)}\n          />\n        );\n      })}\n      {polygonOverlays.map((overlay, index) => {\n        const polygonFillColor = getColor(fillColor, overlay, 'fill');\n        const lineStrokeColor = getColor(strokeColor, overlay, 'stroke');\n        const lineStrokeWidth = getStrokeWidth(strokeWidth, overlay);\n\n        return (\n          <MapPolygon\n            key={index}\n            coordinates={overlay.coordinates}\n            holes={overlay.holes}\n            strokeColor={lineStrokeColor}\n            fillColor={polygonFillColor}\n            strokeWidth={lineStrokeWidth}\n            lineDashPhase={lineDashPhase}\n            lineDashPattern={lineDashPattern}\n            lineCap={lineCap}\n            lineJoin={lineJoin}\n            miterLimit={miterLimit}\n            tappable={tappable}\n            onPress={() => onPress && onPress(overlay)}\n            zIndex={zIndex}\n          />\n        );\n      })}\n    </React.Fragment>\n  );\n};\n\nexport default Geojson;\n\nconst makePointOverlays = (features: Feature[]): AnyPointOverlay[] => {\n  return features\n    .filter(isAnyPointFeature)\n    .map(feature =>\n      makeCoordinatesForAnyPoint(feature.geometry).map(coordinates =>\n        makeOverlayForAnyPoint(coordinates, feature),\n      ),\n    )\n    .reduce((prev, curr) => prev.concat(curr), [])\n    .map(overlay => ({...overlay, type: 'point'}));\n};\n\nconst makeLineOverlays = (features: Feature[]): AnyLineStringOverlay[] => {\n  return features\n    .filter(isAnyLineStringFeature)\n    .map(feature =>\n      makeCoordinatesForAnyLine(feature.geometry).map(coordinates =>\n        makeOverlayForAnyLine(coordinates, feature),\n      ),\n    )\n    .reduce((prev, curr) => prev.concat(curr), [])\n    .map(overlay => ({...overlay, type: 'polyline'}));\n};\n\nconst makePolygonOverlays = (features: Feature[]): AnyPolygonOverlay[] => {\n  const multipolygons: AnyPolygonOverlay[] = features\n    .filter(isMultiPolygonFeature)\n    .map(feature =>\n      makeCoordinatesForMultiPolygon(feature.geometry).map(coordinates =>\n        makeOverlayForAnyPolygon(coordinates, feature),\n      ),\n    )\n    .reduce((prev, curr) => prev.concat(curr), [])\n    .map(overlay => ({...overlay, type: 'polygon'}));\n\n  const polygons: AnyPolygonOverlay[] = features\n    .filter(isPolygonFeature)\n    .map(feature =>\n      makeOverlayForAnyPolygon(\n        makeCoordinatesForPolygon(feature.geometry),\n        feature,\n      ),\n    )\n    .reduce<Omit<AnyPolygonOverlay, 'type'>[]>(\n      (prev, curr) => prev.concat(curr),\n      [],\n    )\n    .map(overlay => ({...overlay, type: 'polygon'}));\n\n  return polygons.concat(multipolygons);\n};\n\nconst makeOverlayForAnyPoint = (\n  coordinates: LatLng,\n  feature: Feature<Point | MultiPoint>,\n): Omit<AnyPointOverlay, 'type'> => {\n  return {feature, coordinates};\n};\n\nconst makeOverlayForAnyLine = (\n  coordinates: LatLng[],\n  feature: Feature<LineString | MultiLineString>,\n): Omit<AnyLineStringOverlay, 'type'> => {\n  return {feature, coordinates};\n};\n\nconst makeOverlayForAnyPolygon = (\n  coordinates: LatLng[][],\n  feature: Feature<Polygon | MultiPolygon>,\n): Omit<AnyPolygonOverlay, 'type'> => {\n  return {\n    feature,\n    coordinates: coordinates[0],\n    holes: coordinates.length > 1 ? coordinates.slice(1) : undefined,\n  };\n};\n\nconst makePoint = (c: Position): LatLng => ({\n  latitude: c[1],\n  longitude: c[0],\n});\n\nconst makeLine = (l: Position[]) => l.map(makePoint);\n\nconst makeCoordinatesForAnyPoint = (geometry: Point | MultiPoint) => {\n  if (geometry.type === 'Point') {\n    return [makePoint(geometry.coordinates)];\n  }\n  return geometry.coordinates.map(makePoint);\n};\n\nconst makeCoordinatesForAnyLine = (geometry: LineString | MultiLineString) => {\n  if (geometry.type === 'LineString') {\n    return [makeLine(geometry.coordinates)];\n  }\n  return geometry.coordinates.map(makeLine);\n};\n\nconst makeCoordinatesForPolygon = (geometry: Polygon) => {\n  return geometry.coordinates.map(makeLine);\n};\n\nconst makeCoordinatesForMultiPolygon = (geometry: MultiPolygon) => {\n  return geometry.coordinates.map(p => p.map(makeLine));\n};\n\nconst getRgbaFromHex = (hex: string, alpha: number = 1) => {\n  const matchArray = hex.match(/\\w\\w/g);\n  if (!matchArray || matchArray.length < 3) {\n    throw new Error('Invalid hex string');\n  }\n  const [r, g, b] = matchArray.map(x => {\n    const subColor = parseInt(x, 16);\n    if (Number.isNaN(subColor)) {\n      throw new Error('Invalid hex string');\n    }\n    return subColor;\n  });\n  return `rgba(${r},${g},${b},${alpha})`;\n};\n\nconst getColor = (\n  prop: string | undefined,\n  overlay: Overlay,\n  colorType: string,\n) => {\n  let color = overlay.feature.properties?.[colorType];\n\n  if (color) {\n    const opacityProperty = colorType + '-opacity';\n    const alpha = overlay.feature.properties?.[opacityProperty];\n\n    if (alpha && alpha !== '0' && color[0] === '#') {\n      color = getRgbaFromHex(color, alpha);\n    }\n\n    return color;\n  } else if (prop) {\n    return prop;\n  }\n\n  return undefined;\n};\n\nconst getStrokeWidth = (\n  prop: GeojsonProps['strokeWidth'],\n  overlay: Overlay,\n) => {\n  return overlay.feature.properties?.['stroke-width'] ?? prop;\n};\n\n// GeoJSON.Feature type-guards\nconst isPointFeature = (feature: Feature): feature is Feature<Point> =>\n  feature.geometry.type === 'Point';\n\nconst isMultiPointFeature = (\n  feature: Feature,\n): feature is Feature<MultiPoint> => feature.geometry.type === 'MultiPoint';\n\nconst isAnyPointFeature = (\n  feature: Feature,\n): feature is Feature<Point> | Feature<MultiPoint> =>\n  isPointFeature(feature) || isMultiPointFeature(feature);\n\nconst isLineStringFeature = (\n  feature: Feature,\n): feature is Feature<LineString> => feature.geometry.type === 'LineString';\n\nconst isMultiLineStringFeature = (\n  feature: Feature,\n): feature is Feature<MultiLineString> =>\n  feature.geometry.type === 'MultiLineString';\n\nconst isAnyLineStringFeature = (\n  feature: Feature,\n): feature is Feature<LineString> | Feature<MultiLineString> =>\n  isLineStringFeature(feature) || isMultiLineStringFeature(feature);\n\nconst isPolygonFeature = (feature: Feature): feature is Feature<Polygon> =>\n  feature.geometry.type === 'Polygon';\n\nconst isMultiPolygonFeature = (\n  feature: Feature,\n): feature is Feature<MultiPolygon> => feature.geometry.type === 'MultiPolygon';\n\ntype OverlayPressEvent = {\n  type:\n    | AnyPointOverlay['type']\n    | AnyLineStringOverlay['type']\n    | AnyPolygonOverlay['type'];\n  feature:\n    | AnyPointOverlay['feature']\n    | AnyLineStringOverlay['feature']\n    | AnyPolygonOverlay['feature'];\n  coordinates:\n    | AnyPointOverlay['coordinates']\n    | AnyLineStringOverlay['coordinates']\n    | AnyPolygonOverlay['coordinates'];\n  holes?: AnyPolygonOverlay['holes'];\n};\n\ntype AnyPointOverlay = {\n  type: 'point';\n  feature: Feature<Point | MultiPoint>;\n  coordinates: LatLng;\n};\n\ntype AnyLineStringOverlay = {\n  type: 'polyline';\n  feature: Feature<LineString | MultiLineString>;\n  coordinates: LatLng[];\n};\n\ntype AnyPolygonOverlay = {\n  type: 'polygon';\n  feature: Feature<Polygon | MultiPolygon>;\n  coordinates: LatLng[];\n  holes?: LatLng[][];\n};\n\ntype Overlay = {\n  type: 'point' | 'polyline' | 'polygon';\n  feature: Feature;\n  coordinates: LatLng | LatLng[];\n  holes?: LatLng[][];\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}